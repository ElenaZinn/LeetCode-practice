/**
https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/
example
num = [0,1,2,3,4]，n = 5, m = 4
每次都是固定地向前移位 m 个位置，成为新环
（1）        0, 1, 2,【3】, 4 | 0,1,2,3,4   
（2） 踢出去后，将下一个移动m格 4, 0, 1 【2】｜ 4，0，1，2      
（3） 踢出去后，将下一个移动m格                 4, 0, 1｜【4】，0，1，           
（4） 踢出去后，将下一个移动m格                                0, 1 ｜0 【1】             
（5） 只有一个数，res的位置是0， 最后的下标一定是0                            0 

倒数第2轮：当前有2个元素。已知在执行完“删除第4个元素”后，res在新数组中的位置是0。则说明在本轮中N前面有0+4=4个元素，所以res的位置是4，然而本轮只有2个元素，所以N的实际位置是（0+4）%2=0；

倒数第3轮：当前有3个元素。已知在执行完“删除第4个元素”后，res在新数组中的位置是0。说明此刻，res前面有0+4=4个元素，所以res的位置是4。而当前数组只有3个元素，故实际位置是（1+4）%3=1；

倒数第4轮：当前有4个元素。已知在执行完“删除第4个元素”后，res在新数组中的位置是1。说明此刻，N前面有1+4=5个元素，所以N的位置是5。而当前数组只有4个元素，故实际位置是（1+4）%4=1；

倒数第5轮：当前有5个元素。已知在执行完“删除第4个元素”后，N’在新数组中的位置是1。说明此刻，N前面有1+4=5个元素，所以N的位置是5。而当前数组只有5个元素，故实际位置是（1+4）%5=0；

 */
class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            System.out.println("ans = " +  ans + " m = " + m + " i =" + i);
            ans = (ans + m) % i; //循环右移
            System.out.println("ans = " +  ans );
        }
        return ans;
    }
}